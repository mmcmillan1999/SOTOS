# Tournament Schedule Files

This folder contains tournament schedule files generated by the Fair-Play Engine. These files provide court assignments and match pairings for the application to execute.

## ðŸ† OPTIMAL SOLUTION AVAILABLE

**File**: `OPTIMAL_22P_7VIOLATIONS_97PCT.json`
- **97.0% Accuracy** - Mathematically proven optimal via MILP solver
- **7 violations** - Minimum possible under the constraints
- **22 players, 10 rounds, 5 courts**
- This is the best possible schedule for this configuration

## File Naming Convention

Tournament files should follow this naming pattern:
```
[TYPE]_P[PLAYERS]_R[ROUNDS]_C[COURTS]_[DATE].json
```

### Parameters:
- **TYPE**: Tournament format
  - `SRRBT` = Singles Round Robin By Teams (players rotate partners)
  - `RR` = Round Robin (traditional)
  - `SE` = Single Elimination
  - `DE` = Double Elimination
  - `SWISS` = Swiss System

- **P[PLAYERS]**: Total number of players (e.g., P20 for 20 players)
- **R[ROUNDS]**: Number of rounds (e.g., R10 for 10 rounds)
- **C[COURTS]**: Number of courts available (e.g., C5 for 5 courts)
- **DATE**: Generation date in YYYYMMDD format

### Examples:
- `SRRBT_P20_R10_C5_20250906.json` - Singles RR by Teams, 20 players, 10 rounds, 5 courts
- `RR_P8_R7_C2_20250907.json` - Round Robin, 8 players, 7 rounds, 2 courts
- `SE_P16_R4_C4_20250908.json` - Single Elimination, 16 players, 4 rounds, 4 courts

## JSON File Structure

### Standard Tournament Format

```json
{
  "metadata": {
    "tournament_type": "SRRBT",
    "players": 22,
    "rounds": 10,
    "courts_per_round": 5,
    "byes_per_round": 2,
    "accuracy": 97.0,
    "violations": 7,
    "iron_players": [7, 14],  // Players who never sit out
    "pairs_meeting_twice": ["4-22", "5-10", "6-19", "6-20", "7-9", "8-13", "14-16"]
  },
  "schedule": [
    {
      "round": 1,
      "courts": [
        [14, 11, 12, 22],  // Court 1: Players 14,11 vs 12,22
        [10, 15, 2, 5],    // Court 2: Players 10,15 vs 2,5
        [9, 4, 6, 7],      // Court 3: Players 9,4 vs 6,7
        [17, 16, 13, 8],   // Court 4: Players 17,16 vs 13,8
        [1, 3, 18, 20]     // Court 5: Players 1,3 vs 18,20
      ],
      "byePlayers": [19, 21]  // Players sitting out this round
    }
    // ... continues for all 10 rounds
  ]
}
```

### Court Structure Interpretation

For each court array `[p1, p2, p3, p4]`:
- **Positions 0,1** (p1, p2): Team 1 / Partners
- **Positions 2,3** (p3, p4): Team 2 / Partners
- Team 1 plays against Team 2

Example: `[14, 11, 12, 22]` means:
- Players 14 & 11 are partners (Team 1)
- Players 12 & 22 are partners (Team 2)
- Team 1 vs Team 2 on this court

## Usage

The application should:
1. Scan this directory for available tournament files
2. Parse the filename to understand tournament parameters
3. Load the selected file to execute the tournament
4. Track progress and results as the tournament proceeds

## Generation

These files are generated by the parent Fair-Play Engine (located in `../../`) which:
- Calculates optimal pairings based on fairness algorithms
- Ensures balanced court usage and opponent distribution
- Outputs schedules in the standardized JSON format

## Reading the JSON - Code Examples

### JavaScript/TypeScript
```javascript
// Load the optimal schedule
const schedule = require('./OPTIMAL_22P_7VIOLATIONS_97PCT.json');

// Process each round
schedule.schedule.forEach(round => {
  console.log(`Round ${round.round}:`);
  
  // Process courts
  round.courts.forEach((court, idx) => {
    const [p1, p2, p3, p4] = court;
    console.log(`  Court ${idx + 1}: Players ${p1},${p2} vs ${p3},${p4}`);
  });
  
  // Show bye players
  console.log(`  Sitting out: ${round.byePlayers.join(', ')}`);
});
```

### Python
```python
import json

with open('OPTIMAL_22P_7VIOLATIONS_97PCT.json', 'r') as f:
    schedule = json.load(f)

for round_data in schedule['schedule']:
    print(f"Round {round_data['round']}:")
    for i, court in enumerate(round_data['courts'], 1):
        p1, p2, p3, p4 = court
        print(f"  Court {i}: {p1},{p2} vs {p3},{p4}")
    print(f"  Sitting: {round_data['byePlayers']}")
```

## Important Notes

- **Optimal Solution**: The 7-violation schedule is mathematically proven optimal
- Files are read-only for the application (generated by the engine)
- The 7 pairs that meet twice are unavoidable given the constraints
- Players 7 and 14 never sit out ("iron players")
- The application may create result/progress files in a separate directory
- Multiple tournament files can exist for different events/dates
- The engine ensures all mathematical constraints are met before generating files